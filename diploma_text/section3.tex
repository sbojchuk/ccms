\section{ПРОГРАМНА РЕАЛІЗАЦІЯ СИСТЕМИ ДЛЯ УПРАВЛІННЯ КОРИСТУВАЧАМИ, ДОКУМЕНТАМИ, ЗАВДАННЯМИ І МОЖЛИВОСТІ СПІЛЬНОЇ РОБОТИ}
\subsection{Реалізація роботи бази даних}
\par Загальна структура бази даних зображено на рисунку \ref{pic:db_shema}. Весь код для створення бази даних реалізовано мовою SQL, за допомогою запитів до БД.
\par Зовнішні посилання створено за допомогою команди Reference. Для прикладу код для створення таблиці користувачів (worker), котра має чотири зовнішні ключі які посилаються на таблиці команди (team), роль користувача (role\_name), тип посади (job\_type\_name) та регіон (region\_name).

\par Відповідно таким чином і реалізовано всі решта таблиць. Код для створення таблиці таблиці користувачів:
\begin{lstlisting}[language=SQL]
DROP TABLE IF EXISTS `worker`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `worker` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `birthday` date DEFAULT NULL,
  `date_hire` date DEFAULT NULL,
  `login` varchar(255) NOT NULL,
  `name` varchar(255) NOT NULL,
  `pass` varchar(255) NOT NULL,
  `phone` varchar(255) DEFAULT NULL,
  `photo` longblob,
  `private_mail` varchar(255) DEFAULT NULL,
  `street` varchar(255) DEFAULT NULL,
  `surname` varchar(255) NOT NULL,
  `version` int(11) DEFAULT NULL,
  `job_type_name` bigint(20) NOT NULL,
  `region_name` bigint(20) NOT NULL,
  `role_name` bigint(20) DEFAULT NULL,
  `team_name` bigint(20) NOT NULL,
  `mobile` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `login` (`login`),
  KEY `FKD162537E30271785` (`team_name`),
  KEY `FKD162537EB0DD720C` (`job_type_name`),
  KEY `FKD162537E520C2F83` (`role_name`),
  KEY `FKD162537EBDECCB25` (`region_name`),
  CONSTRAINT `FKD162537E30271785` FOREIGN KEY (`team_name`) REFERENCES `team` (`id`),
  CONSTRAINT `FKD162537E520C2F83` FOREIGN KEY (`role_name`) REFERENCES `worker_role` (`id`),
  CONSTRAINT `FKD162537EB0DD720C` FOREIGN KEY (`job_type_name`) REFERENCES `worker_job_type` (`id`),
  CONSTRAINT `FKD162537EBDECCB25` FOREIGN KEY (`region_name`) REFERENCES `region` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;	
\end{lstlisting}
\par Посилання на інші таблиці на веб інтерфейсі реалізовано за допомогою випадаючих списків -- це дає можливість забезпечити введення вірних даних і допомагає відобразити вже існуючі в базі даних записи.
Для прикладу візьмемо форму для створення нового користувача та вибору регіону, що зображено на рисунку \ref{pic:page_drop_down}.


\begin{figure}[!ht]
\centering
    \includegraphics[width=0.5\textwidth]{page_drop_down.png}
    \captionof{figure}{Вибір регіону при створенні користувача}\label{pic:page_drop_down}
\end{figure}


\subsection{Реалізація веб інтерфейсу}
\par Веб інтерфейс користувача повинний бути зручний та інтуїтивно зрозумілий кожному користувачеві, тому його було реалізовано в легких тонах та зручно розташовано всі навігаційні елементи.

\begin{figure}[!ht]
\centering
		\includegraphics[width=1.00\textwidth]{page_main.png}
		\captionof{figure}{Загальний інтерфейс програмного продукту}\label{pic:page_main}
\end{figure}
\par Весь інтерфейс сайту поділяється на три основні компоненти: головний блок, навігаційна панель, головне меню. Для зручності розробки цих компонентів використано Apache Tiles, що дає змогу поділяти код на логічні одиниці.
\begin{lstlisting}
<body>
 <div id="wrapper">
  <header>
   <tiles:insertAttribute name="header" ignore="true" />
  </header>
  <section>
   <div class="container_8 clearfix">
    <tiles:insertAttribute name="menu" ignore="true" />
    <tiles:insertAttribute name="body" />
   </div>
   <div id="push"><!-- --></div>
  </section>
 </div>
  <footer>
   <tiles:insertAttribute name="footer" ignore="true" />
  </footer>
 <div class="apple_overlay black" id="overlay">
  <a class="close"></a>
  <iframe class="contentWrap" style="width: 100%; height: 500px"></iframe>
 </div>
 <div style="display: none; position: absolute;" id="calroot">
  <div id="calhead">
   <a id="calprev"></a>
   <div id="caltitle"></div>
   <a id="calnext"></a>
  </div>
  <div id="calbody">
   <div id="caldays">
    <span>Sun</span><span>Mon</span><span>Tue</span><span>Wed</span><span>Thu</span><span>Fri</span><span>Sat</span>
   </div>
   <div id="calweeks">
    <!--   -->
   </div>
  </div>
 </div>
</body>
\end{lstlisting}



\subsubsection{Навігаційна панель}
\par На навігаційній панелі розташовані елементи швидкого доступу до завдань та задач.
З легкістю можна додати будь-яке завдання, при чому вибрати заголовок завдання, детальний опис та кінцевий час виконання (рисунок \ref{pic:page_navigation_new_task});
\begin{figure}[!ht]
\centering
    \includegraphics[width=0.3\textwidth]{page_navigation_new_task.png}
    \captionof{figure}{Приклад створення завдання із навігаційної панелі}\label{pic:page_navigation_new_task}
\end{figure}
\par Для зручності навігаційна панель рухається разом із прокруткою сторінки, тобто якщо навіть користувач перейде в низ сторінки, то йому панель буде завжди доступна -- це зроблено для простоти і швидкості доступу до створення нової нотатки та завдання.
\par Справа на навігаційній панелі розташовано меню користувача. Тут знаходяться кнопки переходу на профіль робочого та кнопка виходу із сайту (рисунок \ref{pic:page_navigation_profile}). Після виходу всі дані, які збережені в сесії будуть видалені.
\begin{figure}[!ht]
\centering
    \includegraphics[width=0.3\textwidth]{page_navigation_profile.png}
    \captionof{figure}{Панель користувача}\label{pic:page_navigation_profile}
\end{figure}


\subsubsection{Головне меню}
\par Навігація по веб ресурсу реалізована за допомогою головного меню. В головному меню відображаються всі доступні на сайті навігаційні посилання:
\begin{enumerate}
  \item головна сторінка;
  \item корпоративна пошта;
  \item завдання;
  \item календар;
  \item нотатки;
  \item документи;
  \item список робочих;
  \item корпоративна вікі;
  \item блог.
\end{enumerate}
\par При переході на будь-яке меню, воно зразу підсвічується -- це зроблено для зручності користувачеві, щоб було зразу видно де він знаходиться в даний момент часу. Програмно це відбувається за допомогою передачі з контролера в модель атрибута із назвою меню:
\begin{lstlisting}[language=Java]
uiModel.addAttribute("menu", "NOTE");
\end{lstlisting}
\par Потім в JSP вигляді головного меню відбувається перевірка на значення поточного меню, і якщо воно сходиться із атрибутом <<menu>> то додається css клас <<active>> (рисунок \ref{pic:page_menu}):

\begin{lstlisting}
<c:choose>
<c:when test="${menu eq 'NOTE' }"><li class="active"><a class="nav-icon icon-note" href="/ccms/notes">Notes</a></li></c:when>
<c:otherwise><li><a class="nav-icon icon-note" href="/ccms/notes">Notes</a></li></c:otherwise>
</c:choose>
\end{lstlisting}

\begin{figure}[!ht]
\centering
    \includegraphics[width=0.30\textwidth]{page_menu.png}
    \captionof{figure}{Навігаційне меню порталу}\label{pic:page_menu}
\end{figure}
\par Відповідно до переходу на певний пункт, відбувається запит контролеру MVC, і вибірка даних із бази даних через контролер з подальшою передачею на вигляд. Для прикладу запит для запису в БД та перевірка на валідність даних:
\begin{lstlisting}
@RequestMapping(method = RequestMethod.POST, produces = "text/html")
public String create(@Valid Note note, BindingResult bindingResult, Model uiModel, HttpServletRequest httpServletRequest) {
    if (bindingResult.hasErrors()) {
        populateEditForm(uiModel, note);
        uiModel.addAttribute("menu", "NOTE");
        return "redirect:/notes";
    }
    uiModel.asMap().clear();
    note.setAuthor(Worker.getPrincipal());
    note.setDatetime(new Date());
    note.persist();
    uiModel.addAttribute("menu", "NOTE");
    return "redirect:/notes";
}
\end{lstlisting}


\subsection{Робота із даними}
\par Для маппінгу даних із форми до бази даних використовується JPA із Hibernate фреймворком поверх нього. Для кожної форми створюється певний домен (по своїй суті persistence bean), котрий за допомогою анотацій із пакету Javax дає змогу переносити об'єкти Java в базу даних (за допомогою використання мови запитів Hibernate Query Language). Для прикладу bean для запису нотаток в базу даних:
\begin{lstlisting} 
@Configurable
@Entity
public class Note {

@NotNull
private String title;

@NotNull
@Size(max = 1000000)
private String text;

@Temporal(TemporalType.TIMESTAMP)
@DateTimeFormat(style = "M-")
private Date datetime;

@ManyToOne
private Worker author;

public static TypedQuery<Note> findNotesByAuthorEquals(Worker author) {
    if (author == null)
        throw new IllegalArgumentException("The author argument is required");
    EntityManager em = Note.entityManager();
    TypedQuery<Note> q = em.createQuery("SELECT o FROM Note AS o WHERE o.author = :author ORDER by o.id DESC", Note.class);
    q.setParameter("author", author);
    return q;
}

public String getTitle() {
    return this.title;
}

public void setTitle(String title) {
    this.title = title;
}
\end{lstlisting}
\par В вище наведеному коді також 


